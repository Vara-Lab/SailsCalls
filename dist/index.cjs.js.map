{"version":3,"file":"index.cjs.js","sources":["../src/index.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/semi */\r\nimport { Sails, ZERO_ADDRESS } from \"sails-js\";\r\nimport { SailsIdlParser } from \"sails-js-parser\";\r\nimport type { KeyringPair, KeyringPair$Json } from '@polkadot/keyring/types';\r\nimport { GearApi, GearKeyring } from \"@gear-js/api\";\r\nimport type { HexString } from \"@gear-js/api/types\";\r\nimport type { \r\n    CallbackType, \r\n    SailsCallbacks, \r\n    ISailsCommandOptions, \r\n    ISailsQueryOptions,\r\n    ISailsCalls,\r\n    WalletSigner,\r\n    SailsCallsError,\r\n    NewContractData,\r\n    SailsCallsContractsData,\r\n    ICreateVoucher,\r\n    IRenewVoucherAmountOfBlocks,\r\n    ITokensToAddToVoucher,\r\n    ICommandResponse,\r\n} from \"./types.js\";\r\nimport type { IKeyringPair } from \"@polkadot/types/types\";\r\n\r\nexport class SailsCalls {\r\n    private sailsInstances: SailsCallsContractsData;\r\n    private gearApi: GearApi;\r\n    private sailsParser: SailsIdlParser;\r\n    // private network: string;\r\n    private accountToSignVouchers: KeyringPair | null;\r\n\r\n    private constructor(\r\n        api: GearApi,\r\n        parser: SailsIdlParser,\r\n        newContractsData: NewContractData[],\r\n        // network: string,\r\n        accountToSignVouchers: KeyringPair | null\r\n    ) {\r\n        this.gearApi = api;\r\n        this.sailsParser = parser;\r\n        this.sailsInstances = {};\r\n        // this.network = network;\r\n        this.accountToSignVouchers = accountToSignVouchers;\r\n\r\n        for (const newContractData of newContractsData) {\r\n            const {\r\n                contractName,\r\n                address,\r\n                idl\r\n            } = newContractData;\r\n            const sailsInstance = new Sails(parser);\r\n\r\n            if (contractName.length > 1 && contractName.substring(0, 2) == '0x') {\r\n                this.gearApi.disconnect();\r\n                throw new Error(`Cant set contract name: invalid name ${contractName}`);\r\n            }\r\n\r\n            if (idl.trim() == '') {\r\n                this.gearApi.disconnect();\r\n                throw new Error('IDL cant be empty');\r\n            }\r\n\r\n            try {\r\n                sailsInstance.setApi(api);\r\n                sailsInstance.setProgramId(address);\r\n                sailsInstance.parseIdl(idl);\r\n            } catch (e) {\r\n                console.error(`Contract data not set for: ${contractName}`);\r\n                this.gearApi.disconnect();\r\n                throw new Error((e as Error).message);\r\n            }\r\n\r\n            this.sailsInstances[contractName] = {\r\n                sailsInstance,\r\n                data: newContractData\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * ## Returs a new SailsCalls instance\r\n     * - Static method that returns a new instance of SailsCalls\r\n     * - The parameter is optional, and its attributes are optionals too:\r\n     *     + newContractsData: Contracts data to store in the SailsCalls instance to be used later\r\n     *     + network: Network to connect the api\r\n     *     + voucherSignerData: sponsor name and mnemonic that will be used to sign the vouchers, etc (only for vouchers - gasless purpose)\r\n     * @param data Optional parameter to set initial contracts data, network and sponsor\r\n     * @returns SailsCalls instance\r\n     * @example\r\n     * // Returns SailsCalls instance with no contracts data.\r\n     * // With network: ws://localhost:9944\r\n     * const sailsCalls = await SailsCalls.new();\r\n     * \r\n     * // Returns SailsCalls instance with no contracts data.\r\n     * // With Network: wss://testnet.vara.network\r\n     * const sailsCalls = await SailsCalls.new({\r\n     *     network: 'wss://testnet.vara.network'\r\n     * });\r\n     * \r\n     * // Returns SailsCalls instance with no contracts data.\r\n     * // With voucher signer and Network: wss://testnet.vara.network\r\n     * const sailsCalls = await SailsCalls.new({\r\n     *     network: 'wss://testnet.vara.network',\r\n     *     voucherSignerData: {\r\n     *         sponsorName: 'Name',\r\n     *         sponsorMnemonic: 'strong void ...'\r\n     *     }\r\n     * });\r\n     * \r\n     * // Returns SailsCalls instance with one contract data.\r\n     * // With network: wss://testnet.vara.network\r\n     * const sailsCalls = await SailsCalls.new({\r\n     *     network: 'wss://testnet.vara.network',\r\n     *     newContractsData: [\r\n     *         {\r\n     *             contractName: \"PingContract\",\r\n     *             address: '0x...',\r\n     *             idl: `...`\r\n     *         }\r\n     *     ]\r\n     * });\r\n     * \r\n     * // Returns SailsCalls instance with one contract data.\r\n     * // With voucher signer and network: ws://localhost:9944\r\n     * const sailsCalls = await SailsCalls.new({\r\n     *     voucherSignerData: {\r\n     *         sponsorName: 'Name',\r\n     *         sponsorMnemonic: 'strong void ...'\r\n     *     },\r\n     *     newContractsData: [\r\n     *         {\r\n     *             contractName: \"PingContract\",\r\n     *             address: '0x...',\r\n     *             idl: `...`\r\n     *         }\r\n     *     ]\r\n     * });\r\n     * \r\n     * // Returns SailsCalls instance with one contract data\r\n     * // With voucher signer and Network: wss://testnet.vara.network\r\n     * const sailsCalls = await SailsCalls.new({\r\n     *     network: 'wss://testnet.vara.network',\r\n     *     voucherSignerData: {\r\n     *         sponsorName: 'Name',\r\n     *         sponsorMnemonic: 'strong void ...'\r\n     *     },\r\n     *     newContractsData: [\r\n     *         {\r\n     *             contractName: \"PingContract\",\r\n     *             address: '0x...',\r\n     *             idl: `...`\r\n     *         },\r\n     *         {\r\n     *             // Contract data\r\n     *         },\r\n     *         // More contracts\r\n     *     ]\r\n     * });\r\n     */\r\n    static new = (data?: ISailsCalls): Promise<SailsCalls> => {\r\n        return new Promise(async (resolve, reject) => {\r\n            const {\r\n                newContractsData = [],\r\n                network = 'ws://localhost:9944',\r\n                voucherSignerData\r\n            } = data || {};\r\n\r\n            let voucherSigner: KeyringPair | null = null;\r\n\r\n            if (voucherSignerData) {\r\n                const { sponsorName, sponsorMnemonic } = voucherSignerData;\r\n                try {\r\n                    voucherSigner = await GearKeyring.fromMnemonic(sponsorMnemonic, sponsorName);\r\n                } catch (e) {\r\n                    const error: SailsCallsError = {\r\n                        sailsCallsError: 'Error while set signer account, voucher signer not set',\r\n                        gearError: (e as Error).message\r\n                    };\r\n    \r\n                    reject(error);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            const api = await GearApi.create({ \r\n                providerAddress: network \r\n            });\r\n\r\n            const sailsParser = await SailsIdlParser.new();\r\n            try {\r\n                const sailsInstance = new SailsCalls(\r\n                    api, \r\n                    sailsParser, \r\n                    newContractsData, \r\n                    // network,    \r\n                    voucherSigner\r\n                )\r\n\r\n                resolve(sailsInstance);\r\n            } catch (e) {\r\n                const error = (e as Error).message;\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * ## SailsCalls command\r\n     * Method to call a command in the contract (to change state).\r\n     * \r\n     * @param url Url form of the method: 'ContractId/Service/Method' or 'Service/Method' \r\n     * in case that contract id is set in SailsCalls instance\r\n     * @param signerData Signer that will sign the extrinsic (with wallet or KeyringPair)\r\n     * @param options Optional, arguments for method and callbacks for each state of extrinsic\r\n     * @returns Promise with response of the method\r\n     * @example\r\n     * const contractId = '0xc234d08426b...b03b83afc4d2fd';\r\n     * const voucherId = '0xc0403jdj03...jfi39gn32l2fw';\r\n     * const sailsCalls = await SailsCalls.new({\r\n     *     network: 'wss://testnet.vara.network',\r\n     *     idl: CONTRACT.idl // String idl\r\n     * });\r\n     * \r\n     * // Call with 'wallet' signer \r\n     * const { signer } = await web3FromSource(account.meta.source);\r\n     * \r\n     * const response = await sailsCalls.command(\r\n     *     `${contractId}/ServiceName/MethodName`,\r\n     *     {\r\n     *         userAddress: account.decodedAddress,\r\n     *         signer\r\n     *     }\r\n     * );\r\n     * \r\n     * // Call with KeyringPair\r\n     * const accountName = 'WalletName';\r\n     * const mnemonic = \"strong word ...\";\r\n     * const keyringPair = await GearKeyring.fromMnemonic(\r\n     *     sponsorMnemonic, \r\n     *     sponsorName\r\n     * );\r\n     * \r\n     * const response = await sailsCalls.command(\r\n     *     `${contractId}/ServiceName/MethodName`,\r\n     *     keyringPair\r\n     * );\r\n     * \r\n     * // Call with contract id set\r\n     * // If it is not specified, it will throw an error\r\n     * sailsCalls.withContractId('0xsjiqw...');\r\n     * const response = await sailsCalls.command(\r\n     *     `ServiceName/MethodName`,\r\n     *     keyringPair\r\n     * );\r\n     * \r\n     * // call using voucher\r\n     * const response = await sailsCalls.command(\r\n     *     `ServiceName/MethodName`,\r\n     *     keyringPair,\r\n     *     {\r\n     *         voucherId\r\n     *     }\r\n     * );\r\n     * \r\n     * // call with associated value\r\n     * // It is necessary that the account has tokens available\r\n     * const response = await sailsCalls.command(\r\n     *     `${contractId}/ServiceName/MethodName`,\r\n     *     {\r\n     *         userAddress: account.decodedAddress,\r\n     *         signer\r\n     *     },\r\n     *     {\r\n     *         // Send one token\r\n     *         tokensToSend: 1_000_000_000_000n,\r\n     *     }\r\n     * );\r\n     * \r\n     * // Call with all callbacks (all are optionals)\r\n     * // It includes async-await calls\r\n     * const response = await sailsCalls.commamd(\r\n     *     `ServiceName/MethodName`,\r\n     *     keyringPair,\r\n     *     {\r\n     *         callbacks: {\r\n     *             onLoad() {\r\n     *                 console.log('Message to send is loading');\r\n     *             },\r\n     *             onLoadAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('Loading message with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onBlock(blockHash) {\r\n     *                 console.log(`Block: ${blockHash}`);\r\n     *             },\r\n     *             onBlockAsync(blockHash) {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log(`Block async: ${blockHash}`);\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onSuccess() {\r\n     *                 console.log('Message send successfully!');\r\n     *             },\r\n     *             onSuccessAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('Message send!, with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onError() {\r\n     *                 console.log('An error ocurred!');\r\n     *             },\r\n     *             onErrorAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('An error ocurred!, with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * );\r\n     * \r\n     * // Call with arguments\r\n     * const response = await sailsCalls.command(\r\n     *     `${contractId}/ServiceName/MethodName`,\r\n     *     keyringPair,\r\n     *     {\r\n     *         callArguments: [\r\n     *             \"Hello!\",\r\n     *             {\r\n     *                 name: \"DAVID\",\r\n     *                 age: 22\r\n     *             }\r\n     *             // More arguments\r\n     *         ]\r\n     *     }\r\n     * );\r\n     * \r\n     * // A call with all options\r\n     * const response = await sailsCalls.commamd(\r\n     *     `${contractId}/ServiceName/MethodName`,\r\n     *     {\r\n     *         userAddress: account.decodedAddress,\r\n     *         signer\r\n     *     },\r\n     *     {\r\n     *         voucherId,\r\n     *         tokensToSend: 1_000_000_000_000n,\r\n     *         callArguments: [\r\n     *             \"Hello!\",\r\n     *             {\r\n     *                 name: \"DAVID\",\r\n     *                 age: 22\r\n     *             }\r\n     *             // More arguments\r\n     *         ],\r\n     *         callbacks: {\r\n     *             onLoad() {\r\n     *                 console.log('Message to send is loading');\r\n     *             },\r\n     *             onLoadAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('Loading message with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onBlock(blockHash) {\r\n     *                 console.log(`Block: ${blockHash}`);\r\n     *             },\r\n     *             onBlockAsync(blockHash) {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log(`Block async: ${blockHash}`);\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onSuccess() {\r\n     *                 console.log('Message send successfully!');\r\n     *             },\r\n     *             onSuccessAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('Message send!, with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onError() {\r\n     *                 console.log('An error ocurred!');\r\n     *             },\r\n     *             onErrorAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('An error ocurred!, with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * );\r\n     */\r\n    // command = (url: string, , options?: SailsCommandOptions): Promise<any> => {\r\n    command = (options: ISailsCommandOptions): Promise<ICommandResponse> => {\r\n        return new Promise(async (resolve, reject) => {\r\n            const {\r\n                signerData,\r\n                contractToCall,\r\n                serviceName,\r\n                methodName,\r\n                callArguments,\r\n                tokensToSend = 0n,\r\n                voucherId,\r\n                gasLimit,\r\n                callbacks\r\n            } = options;\r\n\r\n            let contractSailsInstance: Sails;\r\n\r\n            if (contractToCall) {\r\n                if (typeof contractToCall === 'string') {\r\n                    const temp = this.sailsInstances[contractToCall];\r\n                    if (!temp) {\r\n                        const error: SailsCallsError = {\r\n                            sailsCallsError: `Contract name '${contractToCall}' is not set in SailsCalls instance`\r\n                        };\r\n        \r\n                        reject(error);\r\n                        return;\r\n                    }\r\n\r\n                    contractSailsInstance = temp.sailsInstance;\r\n                } else {\r\n                    contractSailsInstance = new Sails(this.sailsParser);\r\n                    try {\r\n                        contractSailsInstance.setApi(this.gearApi);\r\n                        contractSailsInstance.parseIdl(contractToCall.idl);\r\n                        contractSailsInstance.setProgramId(contractToCall.address);\r\n                    } catch (e) {\r\n                        const error: SailsCallsError = {\r\n                            sailsError: (e as Error).message\r\n                        };\r\n        \r\n                        reject(error);\r\n                        return;\r\n                    }\r\n                }\r\n            } else {\r\n                const contractNames = Object.keys(this.sailsInstances);\r\n\r\n                if (contractNames.length < 1) {\r\n                    const error: SailsCallsError = {\r\n                        sailsCallsError: 'No contracts stored in SailsCalls instance'\r\n                    };\r\n\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                contractSailsInstance = this.sailsInstances[contractNames[0]].sailsInstance;\r\n            }\r\n\r\n            const serviceNames = this.servicesFromSailsInstance(contractSailsInstance);\r\n\r\n            if (!serviceNames.includes(serviceName)) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: `Service name '${serviceName}' does not exists in contract.\\nServices: [${serviceNames}]`\r\n                };\r\n\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            const functionsNames = this.serviceFunctionNamesFromSailsInstance(\r\n                contractSailsInstance, \r\n                serviceName, \r\n                'functions'\r\n            );\r\n\r\n            if (!functionsNames.includes(methodName)) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: `Function name '${methodName}' does not exists in service '${serviceName}'.\\nFunctions: [${functionsNames}]`\r\n                };\r\n\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            await this.processCallBack('asynconload', callbacks);\r\n            this.processCallBack('onload', callbacks);\r\n\r\n            const temp = contractSailsInstance\r\n                .services[serviceName]\r\n                .functions[methodName];\r\n\r\n            const transaction = callArguments \r\n                ? temp(...callArguments) \r\n                : temp();\r\n\r\n            try  {\r\n                if (gasLimit) {\r\n                    if (typeof gasLimit === 'object') {\r\n                        await transaction.calculateGas(\r\n                            false,\r\n                            gasLimit.extraGasInCalculatedGasFees\r\n                        );\r\n                    } else {\r\n                        transaction.withGas(gasLimit);\r\n                    }\r\n                } else {\r\n                    await transaction.calculateGas(false, 10);\r\n                }\r\n\r\n                if (voucherId) transaction.withVoucher(voucherId);\r\n\r\n                if ('signer' in signerData) {\r\n                    const { userAddress, signer } = signerData as WalletSigner;\r\n                    transaction.withAccount(userAddress, { signer });\r\n                } else {\r\n                    const keyringPair = signerData as IKeyringPair;\r\n                    transaction.withAccount(keyringPair);\r\n                }\r\n\r\n                transaction.withValue(tokensToSend);\r\n\r\n                const sailsResponse = await transaction.signAndSend();\r\n\r\n                await this.processCallBack('asynconblock', callbacks, sailsResponse.blockHash);\r\n                this.processCallBack('onblock', callbacks, sailsResponse.blockHash);\r\n                \r\n                const serviceResponse = await sailsResponse.response();\r\n\r\n                await this.processCallBack('asynconsuccess', callbacks);\r\n                this.processCallBack('onsuccess', callbacks);\r\n\r\n                resolve({\r\n                    ...sailsResponse,\r\n                    response: serviceResponse\r\n                });\r\n            } catch (e) {\r\n                const sailsError = (e as Error).message;\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: 'error while sending message',\r\n                    sailsError: sailsError\r\n                };\r\n\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * ## SailsCalls query\r\n     * Method to call a query in the contract (read state)\r\n     * @param url Url form of the method: 'ContractId/Service/Method' or 'Service/Method' \r\n     * in case that contract id is set in SailsCalls instance\r\n     * @param options arguments for query and callbacks for each state of query, the user address is optional \r\n     * @returns Promise with response of the query\r\n     * @example\r\n     * const contractId = '0xc234d08426b...b03b83afc4d2fd';\r\n     * const sailsCalls = await SailsCalls.new({\r\n     *     network: 'wss://testnet.vara.network',\r\n     *     idl: CONTRACT.idl // String idl\r\n     * });\r\n     * \r\n     * // Simple query \r\n     * // The addres that SailsCalls will use is the 'zero' address\r\n     * // because userId is not specified\r\n     * const response = await sailsCalls.query(\r\n     *     `${contractId}/ServiceName/MethodName`\r\n     * );\r\n     * \r\n     * // Simple query with user id\r\n     * const response = await sailsCalls.query(\r\n     *     `${contractId}/ServiceName/MethodName`,\r\n     *     {\r\n     *         userId: account.decodedAddress\r\n     *     }\r\n     * );\r\n     * \r\n     * // Query with contract id set \r\n     * // If it is not specified, it will throw an error\r\n     * sailsCalls..withContractId('0xsjiqw...');\r\n     * const response = await sailsCalls.query(\r\n     *     `ServiceName/MethodName`,\r\n     *     {\r\n     *         userId: account.decodedAddress\r\n     *     }\r\n     * );\r\n     * \r\n     * // Query with arguments\r\n     * const response = await sailsCalls.query(\r\n     *     `ServiceName/MethodName`,\r\n     *     {\r\n     *         userId: account.decodedAddress,\r\n     *         callArguments: [\r\n     *             \"Hello\",\r\n     *             {\r\n     *                 name: 'David',\r\n     *                 age: 22,\r\n     *             },\r\n     *             // etc\r\n     *         ]\r\n     *     }\r\n     * );\r\n     * \r\n     * // Query with callbacks\r\n     * const response = await sailsCalls.query(\r\n     *     `ServiceName/MethodName`,\r\n     *     {\r\n     *         userId: account.decodedAddress,\r\n     *         callbacks: {\r\n     *             onLoad() {\r\n     *                 console.log('Message to send is loading');\r\n     *             },\r\n     *             onLoadAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('Loading message with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onSuccess() {\r\n     *                 console.log('Message send successfully!');\r\n     *             },\r\n     *             onSuccessAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('Message send!, with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onError() {\r\n     *                 console.log('An error ocurred!');\r\n     *             },\r\n     *             onErrorAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('An error ocurred!, with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * );\r\n     * \r\n     * \r\n     * // Query with all options:\r\n     * const response = await sailsCalls.query(\r\n     *     `ServiceName/MethodName`,\r\n     *     {\r\n     *         userId: account.decodedAddress,\r\n     *         callArguments: [\r\n     *             \"Hello\",\r\n     *             {\r\n     *                 name: 'David',\r\n     *                 age: 22,\r\n     *             },\r\n     *             // etc\r\n     *         ],\r\n     *         callbacks: {\r\n     *             onLoad() {\r\n     *                 console.log('Message to send is loading');\r\n     *             },\r\n     *             onLoadAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('Loading message with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onSuccess() {\r\n     *                 console.log('Message send successfully!');\r\n     *             },\r\n     *             onSuccessAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('Message send!, with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             },\r\n     *             onError() {\r\n     *                 console.log('An error ocurred!');\r\n     *             },\r\n     *             onErrorAsync() {\r\n     *                 return new Promise(async resolve => {\r\n     *                     console.log('An error ocurred!, with async');\r\n     *                     resolve();\r\n     *                 });\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * );\r\n     * \r\n     */\r\n    query = (options: ISailsQueryOptions): Promise<any> => {\r\n        return new Promise(async (resolve, reject) => {\r\n            const {\r\n                contractToCall,\r\n                serviceName,\r\n                methodName,\r\n                userAddress = ZERO_ADDRESS,\r\n                callArguments = [],\r\n                callbacks\r\n            } = options;\r\n\r\n            let contractSailsInstance: Sails;\r\n\r\n            if (contractToCall) {\r\n                if (typeof contractToCall === 'string') {\r\n                    const temp = this.sailsInstances[contractToCall];\r\n                    if (!temp) {\r\n                        const error: SailsCallsError = {\r\n                            sailsCallsError: `Contract name '${contractToCall}' is not set in SailsCalls instance`,\r\n                        };\r\n\r\n                        reject(error);\r\n                        return;\r\n                    }\r\n\r\n                    contractSailsInstance = temp.sailsInstance;\r\n                } else {\r\n                    contractSailsInstance = new Sails(this.sailsParser);\r\n                    try {\r\n                        contractSailsInstance.setApi(this.gearApi);\r\n                        contractSailsInstance.parseIdl(contractToCall.idl);\r\n                        contractSailsInstance.setProgramId(contractToCall.address);\r\n                    } catch (e) {\r\n                        const error: SailsCallsError = {\r\n                            sailsError: (e as Error).message\r\n                        };\r\n\r\n                        reject(error);\r\n                        return;\r\n                    }\r\n                }\r\n            } else {\r\n                const contractNames = Object.keys(this.sailsInstances);\r\n\r\n                if (contractNames.length < 1) {\r\n                    const error: SailsCallsError = {\r\n                        sailsCallsError: 'No contracts stored in SailsCalls instance'\r\n                    };\r\n\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                contractSailsInstance = this.sailsInstances[contractNames[0]].sailsInstance;\r\n            }\r\n\r\n            const serviceNames = this.servicesFromSailsInstance(contractSailsInstance);\r\n\r\n            if (!serviceNames.includes(serviceName)) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: `Service name '${serviceName}' does not exists in contract.\\nServices: [${serviceNames}]`\r\n                };\r\n\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            const functionsNames = this.serviceFunctionNamesFromSailsInstance(\r\n                contractSailsInstance, \r\n                serviceName, \r\n                'queries'\r\n            );\r\n\r\n            if (!functionsNames.includes(methodName)) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: `Query name '${methodName}' does not exists in service '${serviceName}'.\\nQueries: [${functionsNames}]`\r\n                };\r\n\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            await this.processCallBack('asynconload', callbacks);\r\n            this.processCallBack('onload', callbacks);\r\n\r\n            const queryMethod = contractSailsInstance\r\n                .services[serviceName]\r\n                .queries[methodName];\r\n\r\n            try {\r\n                const queryResponse = await queryMethod(\r\n                    userAddress, \r\n                    undefined, \r\n                    undefined, \r\n                    ...callArguments\r\n                );\r\n\r\n                await this.processCallBack('asynconsuccess', callbacks);\r\n                this.processCallBack('onsuccess', callbacks);\r\n\r\n                resolve(queryResponse);\r\n            } catch(e) {\r\n                await this.processCallBack('asynconerror', callbacks);\r\n                this.processCallBack('onerror', callbacks);\r\n\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: 'Error while calling query method',\r\n                    sailsError: (e as Error).message\r\n                };\r\n\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * ## Set account to sign feature vouchers\r\n     * @param sponsorMnemonic Sponsor mnemonic to sign vouchers\r\n     * @param sponsorName Sponsor name to sign vouchers\r\n     * @returns void that indicates that signer was set\r\n     * @example\r\n     * const sails = awais SailsCalls.new();\r\n     * await sails.withAccountToSignVouchers({\r\n     *     sponsorName: 'SponsorName',\r\n     *     sponsorMnemonic: 'strong await ...'\r\n     * });\r\n     */\r\n    withAccountToSignVouchers = (\r\n        sponsorMnemonic: string,\r\n        sponsorName: string\r\n    ): Promise<void> => {\r\n        return new Promise(async (resolve, reject) => {\r\n            try {\r\n                const voucherSigner = await GearKeyring.fromMnemonic(\r\n                    sponsorMnemonic, \r\n                    sponsorName\r\n                );\r\n                this.accountToSignVouchers = voucherSigner;\r\n\r\n                resolve();\r\n            } catch (e) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: 'Error while set signer account, voucher signer not set',\r\n                    gearError: (e as Error).message\r\n                };\r\n\r\n                reject(error);\r\n            } \r\n        });\r\n    }\r\n\r\n    \r\n\r\n    /**\r\n     * ## Creates a new voucher\r\n     * Create a new voucher for an address to the stored contract id\r\n     * The instance need to have the contract id \"stored\" to be able to do this action\r\n     * @param address User address to afiliate voucher\r\n     * @param initialTokensInVoucher initial tokens for the voucher\r\n     * @param initialExpiredTimeInBlocks initial time expiration in blocks\r\n     * @param callbacks callback for each state of the voucher action\r\n     * @returns issued voucher id\r\n     * @example\r\n     * const userAddress = account.decodedAddress; // 0xjfm2...\r\n     * const contractId = '0xeejnf2...';\r\n     * // You can set the contract id at start of SailsCalls\r\n     * const sails = await SailsCalls.new({\r\n     *     contractId\r\n     * });\r\n     * \r\n     * sails.withContractId(contractId); // or later with its method\r\n     * \r\n     * const voucherId = await sails.createVoucher(\r\n     *     userAddress, \r\n     *     3, // 3 Varas\r\n     *     1_200, // Expiration time in blocks (one hour)\r\n     *     { // All callbacks are optionals\r\n     *         onLoad() {\r\n     *             console.log('Voucher will be created');\r\n     *         },\r\n     *         onLoadAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Voucher will be created');\r\n     *                 resolve();\r\n     *             }\r\n     *         },\r\n     *         onSuccess() {\r\n     *             console.log('Voucher created!');\r\n     *         },\r\n     *         onSuccessAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Voucher created!');\r\n     *                 resolve();\r\n     *             }\r\n     *         },\r\n     *         onError() {\r\n     *             console.log('Error while creating voucher');\r\n     *         },\r\n     *         onErrorAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Error while creating voucher');\r\n     *                 resolve();\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * );\r\n     * \r\n     */\r\n    // createVoucher = (\r\n    //     userAddress: HexString,\r\n    //     initialTokensInVoucher: number,\r\n    //     initialExpiredTimeInBlocks: number,\r\n    //     callbacks?: SailsCallbacks\r\n    // ): Promise<HexString> => {\r\n    createVoucher = (options: ICreateVoucher): Promise<HexString> => {\r\n        const {\r\n            contractToSetVoucher,\r\n            userAddress,\r\n            initialTokensInVoucher,\r\n            initialExpiredTimeInBlocks,\r\n            enableLogs = false,\r\n            callbacks\r\n        } = options;\r\n\r\n        return new Promise(async (resolve, reject) => {\r\n            const contractsId: HexString[] = [];\r\n\r\n            if (contractToSetVoucher) {\r\n                if (typeof contractToSetVoucher !== 'object') {\r\n                    if (contractToSetVoucher.substring(0, 2) != '0x') {\r\n                        const temp = this.sailsInstances[contractToSetVoucher];\r\n\r\n                        if (!temp) {\r\n                            const error: SailsCallsError = {\r\n                                sailsCallsError: `Contract name '${contractToSetVoucher}' does not exists`\r\n                            };\r\n                            reject(error);\r\n                            return;\r\n                        }\r\n\r\n                        contractsId.push(temp.data.address);\r\n                    } else {\r\n                        contractsId.push(contractToSetVoucher as HexString);\r\n                    }\r\n                } else {\r\n                    contractsId.push(...contractToSetVoucher);\r\n                }\r\n            } else {\r\n                const contractNames = Object.keys(this.sailsInstances);\r\n\r\n                if (contractNames.length < 1) {\r\n                    const error: SailsCallsError = {\r\n                        sailsCallsError: 'No contracts stored in SailsCalls instance'\r\n                    };\r\n\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                const contractName = contractNames[0];\r\n                const contractAddress = this.sailsInstances[contractName].data.address;\r\n                contractsId.push(contractAddress);\r\n            }\r\n\r\n            try {\r\n                const voucherId = this.generateVoucher(\r\n                    userAddress,\r\n                    contractsId,\r\n                    initialTokensInVoucher,\r\n                    initialExpiredTimeInBlocks,\r\n                    enableLogs,\r\n                    callbacks\r\n                );\r\n\r\n                resolve(voucherId);\r\n            } catch (e) {\r\n                reject(e);\r\n            }   \r\n        });\r\n    }\r\n\r\n     /**\r\n     * ## Creates a new voucher\r\n     * Create a new voucher for an address to specified contracts id\r\n     * The function create a voucher for an user address and specified contracts id\r\n     * @param address User address to afiliate voucher\r\n     * @param contractsId Contracts id to afilliate the voucher\r\n     * @param initialTokensInVoucher initial tokens for the voucher\r\n     * @param initialExpiredTimeInBlocks initial time expiration in blocks\r\n     * @param callbacks callback for each state of the voucher action\r\n     * @returns issued voucher id\r\n     * @example\r\n     * const userAddress = account.decodedAddress; // 0xjfm2...\r\n     * const contractId = '0xeejnf2...';\r\n     * // You can set the contract id at start of SailsCalls\r\n     * const sails = await SailsCalls.new();\r\n     * \r\n     * const voucherId = await sails.createVoucherWithContractId(\r\n     *     userAddress, \r\n     *     [contractId],\r\n     *     3, // 3 Varas\r\n     *     1_200, // Expiration time in blocks (one hour)\r\n     *     { // All callbacks are optionals\r\n     *         onLoad() {\r\n     *             console.log('Voucher will be created');\r\n     *         },\r\n     *         onLoadAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Voucher will be created');\r\n     *                 resolve();\r\n     *             }\r\n     *         },\r\n     *         onSuccess() {\r\n     *             console.log('Voucher created!');\r\n     *         },\r\n     *         onSuccessAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Voucher created!');\r\n     *                 resolve();\r\n     *             }\r\n     *         },\r\n     *         onError() {\r\n     *             console.log('Error while creating voucher');\r\n     *         },\r\n     *         onErrorAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Error while creating voucher');\r\n     *                 resolve();\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * );\r\n     * \r\n     */\r\n    // createVoucherWithContractsId = (\r\n    //     userAddress: HexString,\r\n    //     contractsId: HexString[],\r\n    //     initialTokensInVoucher: number,\r\n    //     initialExpiredTimeInBlocks: number,\r\n    //     callbacks?: SailsCallbacks\r\n    // ): Promise<HexString> => {\r\n    //     return new Promise(async (resolve, reject) => {\r\n    //         try {\r\n    //             const voucherId = this.generateVoucher(\r\n    //                 userAddress,\r\n    //                 contractsId,\r\n    //                 initialTokensInVoucher,\r\n    //                 initialExpiredTimeInBlocks,\r\n    //                 callbacks\r\n    //             );\r\n\r\n    //             resolve(voucherId);\r\n    //         } catch (e) {\r\n    //             reject(e);\r\n    //         }\r\n    //     });\r\n    // }\r\n\r\n\r\n    private generateVoucher = (\r\n        userAddress: HexString,\r\n        contractsId: HexString[],\r\n        initialTokensInVoucher: number,\r\n        initialExpiredTimeInBlocks: number,\r\n        enableLogs: boolean,\r\n        callbacks?: SailsCallbacks\r\n    ): Promise<HexString> => {\r\n        return new Promise(async (resolve, reject) => {\r\n            if (!this.accountToSignVouchers) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: 'Account to sign vouchers is not set'\r\n                }\r\n                reject(error);  \r\n                return;\r\n            }\r\n\r\n            if (initialTokensInVoucher < 1) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: 'Min limit of initial tokens is 1'\r\n                }\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            if (initialExpiredTimeInBlocks < 20) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: `Min limit of blocks is 20, given: ${initialExpiredTimeInBlocks}`\r\n                }\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            const voucherIssued = await this.gearApi\r\n                .voucher\r\n                .issue(\r\n                    userAddress,\r\n                    1e12 * initialTokensInVoucher,\r\n                    initialExpiredTimeInBlocks,\r\n                    contractsId\r\n                );\r\n\r\n            try {\r\n                await this.signVoucherAction(\r\n                    voucherIssued.extrinsic,\r\n                    enableLogs,\r\n                    callbacks\r\n                );\r\n\r\n                resolve(voucherIssued.voucherId);\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * ## Renew a voucher at specified blocks\r\n     * @param userAddress address affiliated with the voucher\r\n     * @param voucherId voucher id to renew \r\n     * @param numOfBlocks number of blocks (min 20)\r\n     * @param callbacks optional callbacks to each state of the voucher action\r\n     * @returns void\r\n     * @example\r\n     * const userAddress = account.decodedAddress; // 0xjfm2...\r\n     * const contractId = '0xeejnf2...';\r\n     * const sails = await SailsCalls.new();\r\n     * \r\n     * await sails.renewVoucherAmountOfBlocks(\r\n     *     userAddress,\r\n     *     contractId,\r\n     *     1_200, // 1200 blocks = an hour \r\n     *     { // All callbacks are optionals\r\n     *         onLoad() {\r\n     *             console.log('Voucher will be renewed');\r\n     *         },\r\n     *         onLoadAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Voucher will be renewed');\r\n     *                 resolve();\r\n     *             }\r\n     *         },\r\n     *         onSuccess() {\r\n     *             console.log('Voucher will be renewed');\r\n     *         },\r\n     *         onSuccessAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Voucher will be renewed');\r\n     *                 resolve();\r\n     *             }\r\n     *         },\r\n     *         onError() {\r\n     *             console.log('Voucher will be renewed');\r\n     *         },\r\n     *         onErrorAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Voucher will be renewed');\r\n     *                 resolve();\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * );\r\n     */\r\n    // renewVoucherAmountOfBlocks = (\r\n    //     userAddress: HexString,\r\n    //     voucherId: HexString,\r\n    //     numOfBlocks: number,\r\n    //     callbacks?: SailsCallbacks\r\n    // ): Promise<void> => {\r\n    renewVoucherAmountOfBlocks = (options: IRenewVoucherAmountOfBlocks): Promise<void> => {\r\n        const {\r\n            userAddress,\r\n            voucherId,\r\n            numOfBlocks,\r\n            enableLogs = false,\r\n            callbacks\r\n        } = options;\r\n        return new Promise(async (resolve, reject) => {\r\n            if (numOfBlocks < 20) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: `Minimum block quantity is 20, ${numOfBlocks} were given`\r\n                };\r\n\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            const newVoucherData = { //: IUpdateVoucherParams = {\r\n                prolongDuration: numOfBlocks,\r\n            };\r\n\r\n            const voucherUpdate = this.gearApi.voucher.update(userAddress, voucherId, newVoucherData);\r\n\r\n            try {\r\n                await this.signVoucherAction(\r\n                    voucherUpdate,\r\n                    enableLogs,\r\n                    callbacks\r\n                );\r\n\r\n                resolve();\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * ## Adds tokens to a voucher\r\n     * @param userAddress address associated with the voucher id\r\n     * @param voucherId voucher id to add the tokens\r\n     * @param numOfTokens address associated with the voucher id\r\n     * @param callbacks optional callbacks to each state of the voucher action\r\n     * @returns void\r\n     * @example\r\n     * const userAddress = account.decodedAddress; // 0xjfm2...\r\n     * const voucherId = '0xeejnf2...';\r\n     * const sails = await SailsCalls.new();\r\n     * \r\n     * await sails.addTokensToVoucher(\r\n     *     userAddress,\r\n     *     voucherId,\r\n     *     2, // Two tokens\r\n     *     { // All callbacks are optionals\r\n     *         onLoad() {\r\n     *             console.log('Will add tokens to voucher');\r\n     *         },\r\n     *         onLoadAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Will add tokens to voucher');\r\n     *                 resolve();\r\n     *             }\r\n     *         },\r\n     *         onSuccess() {\r\n     *             console.log('Tokens added to voucher!');\r\n     *         },\r\n     *         onSuccessAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Tokens added to voucher!');\r\n     *                 resolve();\r\n     *             }\r\n     *         },\r\n     *         onError() {\r\n     *             console.log('Error while adding tokens to voucher');\r\n     *         },\r\n     *         onErrorAsync() {\r\n     *             return new Promise(async resolve => {\r\n     *                 console.log('Async actions');\r\n     *                 console.log('Error while adding tokens to voucher');\r\n     *                 resolve();\r\n     *             }\r\n     *         }\r\n     *     }\r\n     * );\r\n     */\r\n    // addTokensToVoucher = (\r\n    //     userAddress: HexString,\r\n    //     voucherId: string, \r\n    //     numOfTokens: number,\r\n    //     callbacks?: SailsCallbacks\r\n    // ): Promise<void> => {\r\n    addTokensToVoucher = (options: ITokensToAddToVoucher): Promise<void> => {\r\n        const {\r\n            userAddress,\r\n            voucherId,\r\n            numOfTokens,\r\n            enableLogs = false,\r\n            callbacks\r\n        } = options;\r\n        return new Promise(async (resolve, reject) => {\r\n            if (numOfTokens <= 0) {\r\n                const error: SailsCallsError = {\r\n                    sailsCallsError: `Cant add less than one token: ${numOfTokens} were given`\r\n                };\r\n\r\n                reject(error);\r\n                return;\r\n            }\r\n\r\n            const newVoucherData = {\r\n                balanceTopUp: 1e12 * numOfTokens\r\n            };\r\n\r\n            const voucherUpdate = this.gearApi.voucher.update(userAddress, voucherId, newVoucherData);\r\n\r\n            try {\r\n                await this.signVoucherAction(\r\n                    voucherUpdate,\r\n                    enableLogs,\r\n                    callbacks\r\n                );\r\n\r\n                resolve();\r\n            } catch (e) {\r\n                reject(e);\r\n            }\r\n        });\r\n    }    \r\n\r\n\r\n    /**\r\n     * ## Obtain all vouchers from an account in a contract\r\n     * @param userAddress user address associated with the voucher\r\n     * @param contractId Optional, contract id of the contract, if not specified, stored contract id will be used\r\n     * @returns list of vouchers id asociated with the user address and contract id.\r\n     * @example\r\n     * const userAddress = account.decodedAddress; // 0xjfm2...\r\n     * const contractId = '0xeejnf2...';\r\n     * const sails = await SailsCalls.new({\r\n     *     contractId\r\n     * });\r\n     * // Will get vouchers from a contract id\r\n     * const vouchersId = await sails.vouchersInContract(\r\n     *     userAddress,\r\n     *     contractId\r\n     * );\r\n     * \r\n     * // Will get vouchers from stored contract id \r\n     * const vouchersId = await sails.vouchersInContract(\r\n     *     userAddress\r\n     * );\r\n     * \r\n     * console.log(vouchersId);\r\n     */\r\n    vouchersInContract = (\r\n        userAddress: HexString, \r\n        contractId?: string | HexString\r\n    ): Promise<HexString[]> => {\r\n        return new Promise(async (resolve, reject) => {\r\n            let contractAddress: HexString;\r\n\r\n            if (contractId) {\r\n                if (contractId.substring(0, 2) != '0x') {\r\n                    const temp = this.sailsInstances[contractId];\r\n\r\n                    if (!temp) {\r\n                        const error: SailsCallsError = {\r\n                            sailsCallsError: 'Contract name does not exists'\r\n                        };\r\n                        reject(error);\r\n                        return;\r\n                    }\r\n\r\n                    contractAddress = temp.data.address;\r\n                } else {\r\n                    contractAddress = contractId as HexString;\r\n                }\r\n            } else {\r\n                const contractNames = Object.keys(this.sailsInstances)\r\n\r\n                if (contractNames.length < 1) {\r\n                    const error: SailsCallsError = {\r\n                        sailsCallsError: 'No contracts stored in SailsCalls instance'\r\n                    };\r\n\r\n                    reject(error);\r\n                    return;\r\n                }\r\n\r\n                const contractName = contractNames[0];\r\n                const temp = this.sailsInstances[contractName].data.address;\r\n                contractAddress = temp;\r\n            }\r\n\r\n            const vouchersData = await this\r\n                .gearApi\r\n                .voucher\r\n                .getAllForAccount(\r\n                    userAddress, \r\n                    contractAddress\r\n                );\r\n            const vouchersId = Object.keys(vouchersData);\r\n\r\n            resolve(vouchersId as HexString[]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * ## Method to know if a voucher has expired\r\n     * @param userAddress user address associated with the voucher\r\n     * @param voucherId voucher id to check\r\n     * @returns Boolean value to check if the voucher is expired\r\n     * @example\r\n     * const userAddress = account.decodedAddress; // 0xjfm2...\r\n     * const contractId = '0xeejnf2...';\r\n     * const sails = await SailsCalls.new();\r\n     * \r\n     * const expired = await sails.voucherIsExpired(\r\n     *     userAddress,\r\n     *     contractId\r\n     * );\r\n     * \r\n     * if (expired) console.log('Voucher expired!');\r\n     */\r\n    voucherIsExpired = (\r\n        userAddress: HexString, \r\n        voucherId: HexString\r\n    ): Promise<boolean> => {\r\n        return new Promise(async resolve => {\r\n            const voucherData = await this\r\n                .gearApi\r\n                .voucher\r\n                .getDetails(userAddress, voucherId);\r\n            const blockHash = await this\r\n                .gearApi\r\n                .blocks\r\n                .getFinalizedHead();\r\n            const blocks = await this\r\n                .gearApi\r\n                .blocks\r\n                .getBlockNumber(blockHash as Uint8Array);\r\n\r\n            resolve(blocks.toNumber() > voucherData.expiry);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * ## Get the balance from a voucher\r\n     * Gets the balance (num of tokens) from a voucher\r\n     * @param voucherId voucher id\r\n     * @returns balance of the voucher\r\n     * @example\r\n     * const voucherId = '0xeejnf2...';\r\n     * const sails = await SailsCalls.new();\r\n     * \r\n     * const voucherBalance = await sails.voucherBalance(voucherId);\r\n     * \r\n     * // prints 'Voucher balance: 5'\r\n     * console.log(`Voucher balance: ${voucherBalance}`);\r\n     */\r\n    voucherBalance = (voucherId: HexString): Promise<number> => {\r\n        return new Promise(async resolve => {\r\n            const voucherBalance = await this.gearApi.balance.findOut(voucherId);\r\n            const voucherBalanceFormated = Number(\r\n                BigInt(voucherBalance.toString()) / 1_000_000_000_000n\r\n            );\r\n\r\n            resolve(voucherBalanceFormated);\r\n        });\r\n    }\r\n\r\n\r\n    private signVoucherAction = (\r\n        extrinsic: any, \r\n        enableLogs: boolean,\r\n        callbacks?: SailsCallbacks\r\n    ): Promise<void> => {\r\n        return new Promise(async (resolve, reject) => {\r\n            if (!this.accountToSignVouchers) {\r\n                reject('Account to sign vouchers is not set');\r\n                return;\r\n            }\r\n\r\n            this.processCallBack('onload', callbacks);\r\n            await this.processCallBack('asynconload', callbacks);\r\n\r\n            try {\r\n                await extrinsic.signAndSend(this.accountToSignVouchers, async (event: any) => {\r\n                    const eventHuman = event.toHuman();\r\n                    if (enableLogs) console.log(eventHuman);\r\n                    const extrinsicJSON: any = eventHuman;\r\n                    if (extrinsicJSON && extrinsicJSON.status !== 'Ready') {\r\n                        const objectKey = Object.keys(extrinsicJSON.status)[0];\r\n                        if (objectKey === 'Finalized') {\r\n                            this.processCallBack('onsuccess', callbacks);\r\n                            await this.processCallBack('asynconsuccess', callbacks);\r\n                            resolve();\r\n                        }\r\n                    }\r\n                });\r\n            } catch (e) {\r\n                this.processCallBack('onerror', callbacks);\r\n                await this.processCallBack('asynconerror', callbacks);\r\n\r\n                const error: SailsCallsError = {\r\n                    gearError: (e as Error).message\r\n                };\r\n\r\n                reject(error);\r\n            }\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * ## Create a new signless account\r\n     * @returns New KeyringPair (Signless account)\r\n     * @example\r\n     * const name = 'CustomName';\r\n     * const sails = await SailsCalls.new();\r\n     * // KeyringPair name will be: signlessPair\r\n     * const signlessAccount = await sails.createNewPairAddress();\r\n     * \r\n     * // KeyringPair name will be: CustomName\r\n     * const signlessAccount = await sails.createNewPairAddress(name);\r\n     */\r\n    createNewKeyringPair = (nameOfSignlessAccount?: string): Promise<KeyringPair> => {\r\n        return new Promise(async (resolve, reject) => {\r\n            try {\r\n                const name = nameOfSignlessAccount\r\n                    ? nameOfSignlessAccount\r\n                    : 'signlessPair';\r\n                const newPair = await GearKeyring.create(name);\r\n                resolve(newPair.keyring);\r\n            } catch (e) {\r\n                console.log(\"Error creating new account pair!\");\r\n                reject(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * ## Lock a keyringPair\r\n     * Function to obtain the \"locked\" version of the signless account\r\n     * @param pair KeyringPair of signless account to lock\r\n     * @param password String to be used to lock the KeyringPair of the signless account\r\n     * @returns a KeyringPair$Json from a locked signless account\r\n     * @example\r\n     * const sails = await SailsCalls.new();\r\n     * const signlessAccount = await sails.createNewPairAddress();\r\n     * const locketKeyringPair = sails.lockeyringPair(\r\n     *     signlessAccount,\r\n     *     \"password\"\r\n     * );\r\n     */\r\n    lockkeyringPair = (pair: KeyringPair, password: string): KeyringPair$Json => {\r\n        return pair.toJson(password);\r\n    }\r\n\r\n    /**\r\n     * ##  Unlocks a locker KeyringPair\r\n     * Function to unlock the \"locked\" version of the signless account (a \"try\" is needed in case the password is incorrect)\r\n     * @param pair Locked signless account\r\n     * @param password string that was previously used to block the signless account\r\n     * @returns The KeyringPair of the locked signless account\r\n     * @example\r\n     * const sails = await SailsCalls.new();\r\n     * const signlessAccount = await sails.createNewPairAddress();\r\n     * const lockedKeyringPair = sails.lockeyringPair(\r\n     *     signlessAccount,\r\n     *     \"password\"\r\n     * );\r\n     * const unlockedKeyringPair = sails.unlockKeyringPair(\r\n     *     lockedKeyringPair,\r\n     *     'password'\r\n     * );\r\n     */\r\n    unlockKeyringPair = (pair: KeyringPair$Json, password: string): KeyringPair => {\r\n        return GearKeyring.fromJson(pair, password);\r\n    }\r\n\r\n    /**\r\n     * ## Format keyringPair from contract\r\n     * Gives a correct format to the blocked signless account that was obtained from the contract, so that it can be unblocked\r\n     * @param signlessData Account blocked from giving the correct format\r\n     * @returns Correct signless account (KeyringPair) for later use\r\n     * @example\r\n     * const contractId = '0xdf234...';\r\n     * const noWalletAddress = '0x7d7dw2...';\r\n     * const idl = '...';\r\n     * const sails = await SailsCalls.new({\r\n     *     contractId,\r\n     *     idl\r\n     * });\r\n     * \r\n     * // Note: Usage example if is used the contract format for signless accounts\r\n     * \r\n     * const keyringPairFromContract = await sails.query(\r\n     *     'QueryService/SignlessAccountData', // Service and method example\r\n     *     {\r\n     *         callArguments: [\r\n     *             noWalletAddress\r\n     *         ]\r\n     *     }\r\n     * );\r\n     * \r\n     * const { signlessAccountData } = contractState;\r\n     * \r\n     * const lockedSignlessData = sails.formatContractSignlessData(\r\n     *     signlessAccountData,\r\n     *     'AccountName'\r\n     * );\r\n     * \r\n     * console.log('Locked signless account');\r\n     * console.log(lockedSignlessData);\r\n     */\r\n    formatContractSignlessData = (signlessData: any, signlessName: string): KeyringPair$Json => {\r\n        const temp = {\r\n            encoding: {\r\n                content: ['pkcs8','sr25519'],\r\n                type: ['scrypt','xsalsa20-poly1305'],\r\n                version: '3'\r\n            },\r\n            meta: {\r\n                name: signlessName\r\n            }\r\n        };\r\n\r\n        const formatEncryptedSignlessData = Object.assign(signlessData, temp);\r\n\r\n        return formatEncryptedSignlessData;\r\n    }\r\n\r\n    /**\r\n     * ## Modify locked KeyringPair\r\n     * Gives the correct format to the information of a locked signless account to send it to the contract\r\n     * @param pair locked signless account to format it\r\n     * @returns locked signless account with the correct format\r\n     * @example\r\n     * const sails = await SailsCalls.new();\r\n     * const keyringPair = await sails.createNewKeyringPair();\r\n     * const lockedKeyringPair = await sails.lockkeyringPair(\r\n     *     keyringPair,\r\n     *     'password'\r\n     * );\r\n     * \r\n     * // It contains the correct locked KeyringPair format for contract\r\n     * const modifiedLockedKeyringPair = sails.modifyPairToContract(lockedKeyringPair);\r\n     * \r\n     * console.log(modifiedLockedKeyringPair);\r\n     */\r\n    modifyPairToContract = (pair: KeyringPair$Json) => {\r\n        const signlessToSend = JSON.parse(JSON.stringify(pair));\r\n        delete signlessToSend['encoding'];\r\n        delete signlessToSend['meta'];\r\n        \r\n        return signlessToSend;\r\n    }\r\n\r\n    disconnectGearApi = async () => {\r\n        await this.gearApi.disconnect();\r\n    }\r\n\r\n    /**\r\n     * ## Change network for SailsCalls instance\r\n     * Set a network for a SailsCalls instance\r\n     * @param network Network to connect \r\n     * @example\r\n     * const sails = await SailsCalls.new();\r\n     * sails.withNetwork('wss://testnet.vara.network');s\r\n     */\r\n    // withNetwork = async (network: string) => {\r\n    //     const api = await GearApi.create({ \r\n    //         providerAddress: network \r\n    //     });\r\n\r\n    //     this.gearApi = api;\r\n    //     this.network = network;\r\n    // }\r\n\r\n    // sailsInstanceWithObjectData = (contractId: HexString, idl: string): Sails => {\r\n    //     const sailsInstance = new Sails(this.sailsParser);\r\n    //     sailsInstance.\r\n    // }\r\n\r\n    servicesFromSailsInstance = (sailsInstance: Sails): string[] => {\r\n        return Object.keys(sailsInstance.services);\r\n    }\r\n\r\n    serviceFunctionNamesFromSailsInstance = (\r\n        sailsInstance: Sails,\r\n        serviceName: string,\r\n        functionsFrom: \"queries\" | \"functions\", \r\n    ): string[] => {\r\n        return Object.keys(sailsInstance.services[serviceName][functionsFrom]);\r\n    }\r\n\r\n    private processCallBack = async (toCall: CallbackType, callbacks?: SailsCallbacks, block?: HexString) => {\r\n        if (!callbacks) return;\r\n        let callback: (() => void) | undefined;\r\n        switch (toCall) {\r\n            case 'onsuccess': \r\n                callback = callbacks.onSuccess;\r\n                if (callback) callback();\r\n                break;\r\n            case 'onerror':\r\n                callback = callbacks.onError;\r\n                if (callback) callback();\r\n                break;\r\n            case 'onload':\r\n                callback = callbacks.onLoad;\r\n                if (callback) callback();\r\n                break;\r\n            case 'onblock':\r\n                callback = callbacks.onBlock;\r\n                if (callback) {\r\n                    const func = callback as (blockHash?: HexString) => void;\r\n                    func(block);\r\n                }\r\n                break;\r\n            case 'asynconsuccess':\r\n                callback = callbacks.onSuccessAsync;\r\n                if (callback) await callback();\r\n                break;\r\n            case 'asynconerror':\r\n                callback = callbacks.onErrorAsync;\r\n                if (callback) await callback();\r\n                return;\r\n            case 'asynconload':\r\n                callback = callbacks.onLoadAsync;\r\n                if (callback) await callback();\r\n                return;\r\n            case 'asynconblock':\r\n                callback = callbacks.onBlockAsync;\r\n                if (callback) {\r\n                    const func = callback as (blockHash?: HexString) => Promise<void>;\r\n                    await func(block);\r\n                }\r\n                return;\r\n        }\r\n    }\r\n    \r\n}\r\n"],"names":["Sails","GearKeyring","api","GearApi","SailsIdlParser","ZERO_ADDRESS"],"mappings":";;;;;;AAAA;MAuBa,UAAU,CAAA;AACX,IAAA,cAAc,CAA0B;AACxC,IAAA,OAAO,CAAU;AACjB,IAAA,WAAW,CAAiB;;AAE5B,IAAA,qBAAqB,CAAqB;AAElD,IAAA,WAAA,CACI,GAAY,EACZ,MAAsB,EACtB,gBAAmC;;IAEnC,qBAAyC,EAAA;AAEzC,QAAA,IAAI,CAAC,OAAO,GAAG,GAAG,CAAC;AACnB,QAAA,IAAI,CAAC,WAAW,GAAG,MAAM,CAAC;AAC1B,QAAA,IAAI,CAAC,cAAc,GAAG,EAAE,CAAC;;AAEzB,QAAA,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;AAEnD,QAAA,KAAK,MAAM,eAAe,IAAI,gBAAgB,EAAE;YAC5C,MAAM,EACF,YAAY,EACZ,OAAO,EACP,GAAG,EACN,GAAG,eAAe,CAAC;AACpB,YAAA,MAAM,aAAa,GAAG,IAAIA,aAAK,CAAC,MAAM,CAAC,CAAC;AAExC,YAAA,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,IAAI,YAAY,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,EAAE;AACjE,gBAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;AAC1B,gBAAA,MAAM,IAAI,KAAK,CAAC,wCAAwC,YAAY,CAAA,CAAE,CAAC,CAAC;aAC3E;AAED,YAAA,IAAI,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,EAAE;AAClB,gBAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;AAC1B,gBAAA,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;aACxC;AAED,YAAA,IAAI;AACA,gBAAA,aAAa,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;AAC1B,gBAAA,aAAa,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC;AACpC,gBAAA,aAAa,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC;aAC/B;YAAC,OAAO,CAAC,EAAE;AACR,gBAAA,OAAO,CAAC,KAAK,CAAC,8BAA8B,YAAY,CAAA,CAAE,CAAC,CAAC;AAC5D,gBAAA,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;AAC1B,gBAAA,MAAM,IAAI,KAAK,CAAE,CAAW,CAAC,OAAO,CAAC,CAAC;aACzC;AAED,YAAA,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,GAAG;gBAChC,aAAa;AACb,gBAAA,IAAI,EAAE,eAAe;aACxB,CAAC;SACL;KACJ;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+EG;AACH,IAAA,OAAO,GAAG,GAAG,CAAC,IAAkB,KAAyB;QACrD,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,MAAM,EACF,gBAAgB,GAAG,EAAE,EACrB,OAAO,GAAG,qBAAqB,EAC/B,iBAAiB,EACpB,GAAG,IAAI,IAAI,EAAE,CAAC;YAEf,IAAI,aAAa,GAAuB,IAAI,CAAC;YAE7C,IAAI,iBAAiB,EAAE;AACnB,gBAAA,MAAM,EAAE,WAAW,EAAE,eAAe,EAAE,GAAG,iBAAiB,CAAC;AAC3D,gBAAA,IAAI;oBACA,aAAa,GAAG,MAAMC,eAAW,CAAC,YAAY,CAAC,eAAe,EAAE,WAAW,CAAC,CAAC;iBAChF;gBAAC,OAAO,CAAC,EAAE;AACR,oBAAA,MAAM,KAAK,GAAoB;AAC3B,wBAAA,eAAe,EAAE,wDAAwD;wBACzE,SAAS,EAAG,CAAW,CAAC,OAAO;qBAClC,CAAC;oBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;oBACd,OAAO;iBACV;aACJ;AAED,YAAA,MAAMC,KAAG,GAAG,MAAMC,WAAO,CAAC,MAAM,CAAC;AAC7B,gBAAA,eAAe,EAAE,OAAO;AAC3B,aAAA,CAAC,CAAC;AAEH,YAAA,MAAM,WAAW,GAAG,MAAMC,4BAAc,CAAC,GAAG,EAAE,CAAC;AAC/C,YAAA,IAAI;gBACA,MAAM,aAAa,GAAG,IAAI,UAAU,CAChCF,KAAG,EACH,WAAW,EACX,gBAAgB;;AAEhB,gBAAA,aAAa,CAChB,CAAA;gBAED,OAAO,CAAC,aAAa,CAAC,CAAC;aAC1B;YAAC,OAAO,CAAC,EAAE;AACR,gBAAA,MAAM,KAAK,GAAI,CAAW,CAAC,OAAO,CAAC;gBACnC,MAAM,CAAC,KAAK,CAAC,CAAC;aACjB;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiMG;;AAEH,IAAA,OAAO,GAAG,CAAC,OAA6B,KAA+B;QACnE,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;YACzC,MAAM,EACF,UAAU,EACV,cAAc,EACd,WAAW,EACX,UAAU,EACV,aAAa,EACb,YAAY,GAAG,EAAE,EACjB,SAAS,EACT,QAAQ,EACR,SAAS,EACZ,GAAG,OAAO,CAAC;AAEZ,YAAA,IAAI,qBAA4B,CAAC;YAEjC,IAAI,cAAc,EAAE;AAChB,gBAAA,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;oBACpC,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;oBACjD,IAAI,CAAC,IAAI,EAAE;AACP,wBAAA,MAAM,KAAK,GAAoB;4BAC3B,eAAe,EAAE,CAAkB,eAAA,EAAA,cAAc,CAAqC,mCAAA,CAAA;yBACzF,CAAC;wBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;wBACd,OAAO;qBACV;AAED,oBAAA,qBAAqB,GAAG,IAAI,CAAC,aAAa,CAAC;iBAC9C;qBAAM;oBACH,qBAAqB,GAAG,IAAIF,aAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;AACpD,oBAAA,IAAI;AACA,wBAAA,qBAAqB,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3C,wBAAA,qBAAqB,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;AACnD,wBAAA,qBAAqB,CAAC,YAAY,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;qBAC9D;oBAAC,OAAO,CAAC,EAAE;AACR,wBAAA,MAAM,KAAK,GAAoB;4BAC3B,UAAU,EAAG,CAAW,CAAC,OAAO;yBACnC,CAAC;wBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;wBACd,OAAO;qBACV;iBACJ;aACJ;iBAAM;gBACH,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AAEvD,gBAAA,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,oBAAA,MAAM,KAAK,GAAoB;AAC3B,wBAAA,eAAe,EAAE,4CAA4C;qBAChE,CAAC;oBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;oBACd,OAAO;iBACV;AAED,gBAAA,qBAAqB,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;aAC/E;YAED,MAAM,YAAY,GAAG,IAAI,CAAC,yBAAyB,CAAC,qBAAqB,CAAC,CAAC;YAE3E,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE;AACrC,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,CAAA,cAAA,EAAiB,WAAW,CAAA,2CAAA,EAA8C,YAAY,CAAG,CAAA,CAAA;iBAC7G,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;AAED,YAAA,MAAM,cAAc,GAAG,IAAI,CAAC,qCAAqC,CAC7D,qBAAqB,EACrB,WAAW,EACX,WAAW,CACd,CAAC;YAEF,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;AACtC,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,CAAkB,eAAA,EAAA,UAAU,iCAAiC,WAAW,CAAA,gBAAA,EAAmB,cAAc,CAAG,CAAA,CAAA;iBAChI,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;YAED,MAAM,IAAI,CAAC,eAAe,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;AACrD,YAAA,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;YAE1C,MAAM,IAAI,GAAG,qBAAqB;iBAC7B,QAAQ,CAAC,WAAW,CAAC;iBACrB,SAAS,CAAC,UAAU,CAAC,CAAC;YAE3B,MAAM,WAAW,GAAG,aAAa;AAC7B,kBAAE,IAAI,CAAC,GAAG,aAAa,CAAC;kBACtB,IAAI,EAAE,CAAC;AAEb,YAAA,IAAK;gBACD,IAAI,QAAQ,EAAE;AACV,oBAAA,IAAI,OAAO,QAAQ,KAAK,QAAQ,EAAE;wBAC9B,MAAM,WAAW,CAAC,YAAY,CAC1B,KAAK,EACL,QAAQ,CAAC,2BAA2B,CACvC,CAAC;qBACL;yBAAM;AACH,wBAAA,WAAW,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;qBACjC;iBACJ;qBAAM;oBACH,MAAM,WAAW,CAAC,YAAY,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;iBAC7C;AAED,gBAAA,IAAI,SAAS;AAAE,oBAAA,WAAW,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC;AAElD,gBAAA,IAAI,QAAQ,IAAI,UAAU,EAAE;AACxB,oBAAA,MAAM,EAAE,WAAW,EAAE,MAAM,EAAE,GAAG,UAA0B,CAAC;oBAC3D,WAAW,CAAC,WAAW,CAAC,WAAW,EAAE,EAAE,MAAM,EAAE,CAAC,CAAC;iBACpD;qBAAM;oBACH,MAAM,WAAW,GAAG,UAA0B,CAAC;AAC/C,oBAAA,WAAW,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;iBACxC;AAED,gBAAA,WAAW,CAAC,SAAS,CAAC,YAAY,CAAC,CAAC;AAEpC,gBAAA,MAAM,aAAa,GAAG,MAAM,WAAW,CAAC,WAAW,EAAE,CAAC;AAEtD,gBAAA,MAAM,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,SAAS,EAAE,aAAa,CAAC,SAAS,CAAC,CAAC;gBAC/E,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,EAAE,aAAa,CAAC,SAAS,CAAC,CAAC;AAEpE,gBAAA,MAAM,eAAe,GAAG,MAAM,aAAa,CAAC,QAAQ,EAAE,CAAC;gBAEvD,MAAM,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,SAAS,CAAC,CAAC;AACxD,gBAAA,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;AAE7C,gBAAA,OAAO,CAAC;AACJ,oBAAA,GAAG,aAAa;AAChB,oBAAA,QAAQ,EAAE,eAAe;AAC5B,iBAAA,CAAC,CAAC;aACN;YAAC,OAAO,CAAC,EAAE;AACR,gBAAA,MAAM,UAAU,GAAI,CAAW,CAAC,OAAO,CAAC;AACxC,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,6BAA6B;AAC9C,oBAAA,UAAU,EAAE,UAAU;iBACzB,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;aACjB;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0IG;AACH,IAAA,KAAK,GAAG,CAAC,OAA2B,KAAkB;QAClD,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,MAAM,EACF,cAAc,EACd,WAAW,EACX,UAAU,EACV,WAAW,GAAGK,oBAAY,EAC1B,aAAa,GAAG,EAAE,EAClB,SAAS,EACZ,GAAG,OAAO,CAAC;AAEZ,YAAA,IAAI,qBAA4B,CAAC;YAEjC,IAAI,cAAc,EAAE;AAChB,gBAAA,IAAI,OAAO,cAAc,KAAK,QAAQ,EAAE;oBACpC,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;oBACjD,IAAI,CAAC,IAAI,EAAE;AACP,wBAAA,MAAM,KAAK,GAAoB;4BAC3B,eAAe,EAAE,CAAkB,eAAA,EAAA,cAAc,CAAqC,mCAAA,CAAA;yBACzF,CAAC;wBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;wBACd,OAAO;qBACV;AAED,oBAAA,qBAAqB,GAAG,IAAI,CAAC,aAAa,CAAC;iBAC9C;qBAAM;oBACH,qBAAqB,GAAG,IAAIL,aAAK,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;AACpD,oBAAA,IAAI;AACA,wBAAA,qBAAqB,CAAC,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AAC3C,wBAAA,qBAAqB,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC;AACnD,wBAAA,qBAAqB,CAAC,YAAY,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC;qBAC9D;oBAAC,OAAO,CAAC,EAAE;AACR,wBAAA,MAAM,KAAK,GAAoB;4BAC3B,UAAU,EAAG,CAAW,CAAC,OAAO;yBACnC,CAAC;wBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;wBACd,OAAO;qBACV;iBACJ;aACJ;iBAAM;gBACH,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AAEvD,gBAAA,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,oBAAA,MAAM,KAAK,GAAoB;AAC3B,wBAAA,eAAe,EAAE,4CAA4C;qBAChE,CAAC;oBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;oBACd,OAAO;iBACV;AAED,gBAAA,qBAAqB,GAAG,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;aAC/E;YAED,MAAM,YAAY,GAAG,IAAI,CAAC,yBAAyB,CAAC,qBAAqB,CAAC,CAAC;YAE3E,IAAI,CAAC,YAAY,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAE;AACrC,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,CAAA,cAAA,EAAiB,WAAW,CAAA,2CAAA,EAA8C,YAAY,CAAG,CAAA,CAAA;iBAC7G,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;AAED,YAAA,MAAM,cAAc,GAAG,IAAI,CAAC,qCAAqC,CAC7D,qBAAqB,EACrB,WAAW,EACX,SAAS,CACZ,CAAC;YAEF,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAE;AACtC,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,CAAe,YAAA,EAAA,UAAU,iCAAiC,WAAW,CAAA,cAAA,EAAiB,cAAc,CAAG,CAAA,CAAA;iBAC3H,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;YAED,MAAM,IAAI,CAAC,eAAe,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;AACrD,YAAA,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;YAE1C,MAAM,WAAW,GAAG,qBAAqB;iBACpC,QAAQ,CAAC,WAAW,CAAC;iBACrB,OAAO,CAAC,UAAU,CAAC,CAAC;AAEzB,YAAA,IAAI;AACA,gBAAA,MAAM,aAAa,GAAG,MAAM,WAAW,CACnC,WAAW,EACX,SAAS,EACT,SAAS,EACT,GAAG,aAAa,CACnB,CAAC;gBAEF,MAAM,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,SAAS,CAAC,CAAC;AACxD,gBAAA,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;gBAE7C,OAAO,CAAC,aAAa,CAAC,CAAC;aAC1B;YAAC,OAAM,CAAC,EAAE;gBACP,MAAM,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;AACtD,gBAAA,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;AAE3C,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,kCAAkC;oBACnD,UAAU,EAAG,CAAW,CAAC,OAAO;iBACnC,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;aACjB;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAED;;;;;;;;;;;AAWG;AACH,IAAA,yBAAyB,GAAG,CACxB,eAAuB,EACvB,WAAmB,KACJ;QACf,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,IAAI;gBACA,MAAM,aAAa,GAAG,MAAMC,eAAW,CAAC,YAAY,CAChD,eAAe,EACf,WAAW,CACd,CAAC;AACF,gBAAA,IAAI,CAAC,qBAAqB,GAAG,aAAa,CAAC;AAE3C,gBAAA,OAAO,EAAE,CAAC;aACb;YAAC,OAAO,CAAC,EAAE;AACR,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,wDAAwD;oBACzE,SAAS,EAAG,CAAW,CAAC,OAAO;iBAClC,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;aACjB;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAID;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyDG;;;;;;;AAOH,IAAA,aAAa,GAAG,CAAC,OAAuB,KAAwB;AAC5D,QAAA,MAAM,EACF,oBAAoB,EACpB,WAAW,EACX,sBAAsB,EACtB,0BAA0B,EAC1B,UAAU,GAAG,KAAK,EAClB,SAAS,EACZ,GAAG,OAAO,CAAC;QAEZ,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;YACzC,MAAM,WAAW,GAAgB,EAAE,CAAC;YAEpC,IAAI,oBAAoB,EAAE;AACtB,gBAAA,IAAI,OAAO,oBAAoB,KAAK,QAAQ,EAAE;oBAC1C,IAAI,oBAAoB,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,EAAE;wBAC9C,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,oBAAoB,CAAC,CAAC;wBAEvD,IAAI,CAAC,IAAI,EAAE;AACP,4BAAA,MAAM,KAAK,GAAoB;gCAC3B,eAAe,EAAE,CAAkB,eAAA,EAAA,oBAAoB,CAAmB,iBAAA,CAAA;6BAC7E,CAAC;4BACF,MAAM,CAAC,KAAK,CAAC,CAAC;4BACd,OAAO;yBACV;wBAED,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;qBACvC;yBAAM;AACH,wBAAA,WAAW,CAAC,IAAI,CAAC,oBAAiC,CAAC,CAAC;qBACvD;iBACJ;qBAAM;AACH,oBAAA,WAAW,CAAC,IAAI,CAAC,GAAG,oBAAoB,CAAC,CAAC;iBAC7C;aACJ;iBAAM;gBACH,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AAEvD,gBAAA,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,oBAAA,MAAM,KAAK,GAAoB;AAC3B,wBAAA,eAAe,EAAE,4CAA4C;qBAChE,CAAC;oBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;oBACd,OAAO;iBACV;AAED,gBAAA,MAAM,YAAY,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACtC,gBAAA,MAAM,eAAe,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC;AACvE,gBAAA,WAAW,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC;aACrC;AAED,YAAA,IAAI;AACA,gBAAA,MAAM,SAAS,GAAG,IAAI,CAAC,eAAe,CAClC,WAAW,EACX,WAAW,EACX,sBAAsB,EACtB,0BAA0B,EAC1B,UAAU,EACV,SAAS,CACZ,CAAC;gBAEF,OAAO,CAAC,SAAS,CAAC,CAAC;aACtB;YAAC,OAAO,CAAC,EAAE;gBACR,MAAM,CAAC,CAAC,CAAC,CAAC;aACb;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuDE;;;;;;;;;;;;;;;;;;;;;;;AA0BK,IAAA,eAAe,GAAG,CACtB,WAAsB,EACtB,WAAwB,EACxB,sBAA8B,EAC9B,0BAAkC,EAClC,UAAmB,EACnB,SAA0B,KACN;QACpB,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE;AAC7B,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,qCAAqC;iBACzD,CAAA;gBACD,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;AAED,YAAA,IAAI,sBAAsB,GAAG,CAAC,EAAE;AAC5B,gBAAA,MAAM,KAAK,GAAoB;AAC3B,oBAAA,eAAe,EAAE,kCAAkC;iBACtD,CAAA;gBACD,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;AAED,YAAA,IAAI,0BAA0B,GAAG,EAAE,EAAE;AACjC,gBAAA,MAAM,KAAK,GAAoB;oBAC3B,eAAe,EAAE,CAAqC,kCAAA,EAAA,0BAA0B,CAAE,CAAA;iBACrF,CAAA;gBACD,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;AAED,YAAA,MAAM,aAAa,GAAG,MAAM,IAAI,CAAC,OAAO;iBACnC,OAAO;iBACP,KAAK,CACF,WAAW,EACX,IAAI,GAAG,sBAAsB,EAC7B,0BAA0B,EAC1B,WAAW,CACd,CAAC;AAEN,YAAA,IAAI;AACA,gBAAA,MAAM,IAAI,CAAC,iBAAiB,CACxB,aAAa,CAAC,SAAS,EACvB,UAAU,EACV,SAAS,CACZ,CAAC;AAEF,gBAAA,OAAO,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;aACpC;YAAC,OAAO,CAAC,EAAE;gBACR,MAAM,CAAC,CAAC,CAAC,CAAC;aACb;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAGD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDG;;;;;;;AAOH,IAAA,0BAA0B,GAAG,CAAC,OAAoC,KAAmB;AACjF,QAAA,MAAM,EACF,WAAW,EACX,SAAS,EACT,WAAW,EACX,UAAU,GAAG,KAAK,EAClB,SAAS,EACZ,GAAG,OAAO,CAAC;QACZ,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,IAAI,WAAW,GAAG,EAAE,EAAE;AAClB,gBAAA,MAAM,KAAK,GAAoB;oBAC3B,eAAe,EAAE,CAAiC,8BAAA,EAAA,WAAW,CAAa,WAAA,CAAA;iBAC7E,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;AAED,YAAA,MAAM,cAAc,GAAG;AACnB,gBAAA,eAAe,EAAE,WAAW;aAC/B,CAAC;AAEF,YAAA,MAAM,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,WAAW,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;AAE1F,YAAA,IAAI;gBACA,MAAM,IAAI,CAAC,iBAAiB,CACxB,aAAa,EACb,UAAU,EACV,SAAS,CACZ,CAAC;AAEF,gBAAA,OAAO,EAAE,CAAC;aACb;YAAC,OAAO,CAAC,EAAE;gBACR,MAAM,CAAC,CAAC,CAAC,CAAC;aACb;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAGD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDG;;;;;;;AAOH,IAAA,kBAAkB,GAAG,CAAC,OAA8B,KAAmB;AACnE,QAAA,MAAM,EACF,WAAW,EACX,SAAS,EACT,WAAW,EACX,UAAU,GAAG,KAAK,EAClB,SAAS,EACZ,GAAG,OAAO,CAAC;QACZ,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,IAAI,WAAW,IAAI,CAAC,EAAE;AAClB,gBAAA,MAAM,KAAK,GAAoB;oBAC3B,eAAe,EAAE,CAAiC,8BAAA,EAAA,WAAW,CAAa,WAAA,CAAA;iBAC7E,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;gBACd,OAAO;aACV;AAED,YAAA,MAAM,cAAc,GAAG;gBACnB,YAAY,EAAE,IAAI,GAAG,WAAW;aACnC,CAAC;AAEF,YAAA,MAAM,aAAa,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,MAAM,CAAC,WAAW,EAAE,SAAS,EAAE,cAAc,CAAC,CAAC;AAE1F,YAAA,IAAI;gBACA,MAAM,IAAI,CAAC,iBAAiB,CACxB,aAAa,EACb,UAAU,EACV,SAAS,CACZ,CAAC;AAEF,gBAAA,OAAO,EAAE,CAAC;aACb;YAAC,OAAO,CAAC,EAAE;gBACR,MAAM,CAAC,CAAC,CAAC,CAAC;aACb;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAGD;;;;;;;;;;;;;;;;;;;;;;;AAuBG;AACH,IAAA,kBAAkB,GAAG,CACjB,WAAsB,EACtB,UAA+B,KACT;QACtB,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,IAAI,eAA0B,CAAC;YAE/B,IAAI,UAAU,EAAE;gBACZ,IAAI,UAAU,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,IAAI,EAAE;oBACpC,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;oBAE7C,IAAI,CAAC,IAAI,EAAE;AACP,wBAAA,MAAM,KAAK,GAAoB;AAC3B,4BAAA,eAAe,EAAE,+BAA+B;yBACnD,CAAC;wBACF,MAAM,CAAC,KAAK,CAAC,CAAC;wBACd,OAAO;qBACV;AAED,oBAAA,eAAe,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC;iBACvC;qBAAM;oBACH,eAAe,GAAG,UAAuB,CAAC;iBAC7C;aACJ;iBAAM;gBACH,MAAM,aAAa,GAAG,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,CAAC,CAAA;AAEtD,gBAAA,IAAI,aAAa,CAAC,MAAM,GAAG,CAAC,EAAE;AAC1B,oBAAA,MAAM,KAAK,GAAoB;AAC3B,wBAAA,eAAe,EAAE,4CAA4C;qBAChE,CAAC;oBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;oBACd,OAAO;iBACV;AAED,gBAAA,MAAM,YAAY,GAAG,aAAa,CAAC,CAAC,CAAC,CAAC;AACtC,gBAAA,MAAM,IAAI,GAAG,IAAI,CAAC,cAAc,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC;gBAC5D,eAAe,GAAG,IAAI,CAAC;aAC1B;YAED,MAAM,YAAY,GAAG,MAAM,IAAI;iBAC1B,OAAO;iBACP,OAAO;AACP,iBAAA,gBAAgB,CACb,WAAW,EACX,eAAe,CAClB,CAAC;YACN,MAAM,UAAU,GAAG,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;YAE7C,OAAO,CAAC,UAAyB,CAAC,CAAC;AACvC,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAED;;;;;;;;;;;;;;;;AAgBG;AACH,IAAA,gBAAgB,GAAG,CACf,WAAsB,EACtB,SAAoB,KACF;AAClB,QAAA,OAAO,IAAI,OAAO,CAAC,OAAM,OAAO,KAAG;YAC/B,MAAM,WAAW,GAAG,MAAM,IAAI;iBACzB,OAAO;iBACP,OAAO;AACP,iBAAA,UAAU,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;YACxC,MAAM,SAAS,GAAG,MAAM,IAAI;iBACvB,OAAO;iBACP,MAAM;AACN,iBAAA,gBAAgB,EAAE,CAAC;YACxB,MAAM,MAAM,GAAG,MAAM,IAAI;iBACpB,OAAO;iBACP,MAAM;iBACN,cAAc,CAAC,SAAuB,CAAC,CAAC;YAE7C,OAAO,CAAC,MAAM,CAAC,QAAQ,EAAE,GAAG,WAAW,CAAC,MAAM,CAAC,CAAC;AACpD,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAED;;;;;;;;;;;;;AAaG;AACH,IAAA,cAAc,GAAG,CAAC,SAAoB,KAAqB;AACvD,QAAA,OAAO,IAAI,OAAO,CAAC,OAAM,OAAO,KAAG;AAC/B,YAAA,MAAM,cAAc,GAAG,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,CAAC;AACrE,YAAA,MAAM,sBAAsB,GAAG,MAAM,CACjC,MAAM,CAAC,cAAc,CAAC,QAAQ,EAAE,CAAC,GAAG,cAAkB,CACzD,CAAC;YAEF,OAAO,CAAC,sBAAsB,CAAC,CAAC;AACpC,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;IAGO,iBAAiB,GAAG,CACxB,SAAc,EACd,UAAmB,EACnB,SAA0B,KACX;QACf,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,IAAI,CAAC,IAAI,CAAC,qBAAqB,EAAE;gBAC7B,MAAM,CAAC,qCAAqC,CAAC,CAAC;gBAC9C,OAAO;aACV;AAED,YAAA,IAAI,CAAC,eAAe,CAAC,QAAQ,EAAE,SAAS,CAAC,CAAC;YAC1C,MAAM,IAAI,CAAC,eAAe,CAAC,aAAa,EAAE,SAAS,CAAC,CAAC;AAErD,YAAA,IAAI;AACA,gBAAA,MAAM,SAAS,CAAC,WAAW,CAAC,IAAI,CAAC,qBAAqB,EAAE,OAAO,KAAU,KAAI;AACzE,oBAAA,MAAM,UAAU,GAAG,KAAK,CAAC,OAAO,EAAE,CAAC;AACnC,oBAAA,IAAI,UAAU;AAAE,wBAAA,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC;oBACxC,MAAM,aAAa,GAAQ,UAAU,CAAC;oBACtC,IAAI,aAAa,IAAI,aAAa,CAAC,MAAM,KAAK,OAAO,EAAE;AACnD,wBAAA,MAAM,SAAS,GAAG,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AACvD,wBAAA,IAAI,SAAS,KAAK,WAAW,EAAE;AAC3B,4BAAA,IAAI,CAAC,eAAe,CAAC,WAAW,EAAE,SAAS,CAAC,CAAC;4BAC7C,MAAM,IAAI,CAAC,eAAe,CAAC,gBAAgB,EAAE,SAAS,CAAC,CAAC;AACxD,4BAAA,OAAO,EAAE,CAAC;yBACb;qBACJ;AACL,iBAAC,CAAC,CAAC;aACN;YAAC,OAAO,CAAC,EAAE;AACR,gBAAA,IAAI,CAAC,eAAe,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC;gBAC3C,MAAM,IAAI,CAAC,eAAe,CAAC,cAAc,EAAE,SAAS,CAAC,CAAC;AAEtD,gBAAA,MAAM,KAAK,GAAoB;oBAC3B,SAAS,EAAG,CAAW,CAAC,OAAO;iBAClC,CAAC;gBAEF,MAAM,CAAC,KAAK,CAAC,CAAC;aACjB;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAGD;;;;;;;;;;;AAWG;AACH,IAAA,oBAAoB,GAAG,CAAC,qBAA8B,KAA0B;QAC5E,OAAO,IAAI,OAAO,CAAC,OAAO,OAAO,EAAE,MAAM,KAAI;AACzC,YAAA,IAAI;gBACA,MAAM,IAAI,GAAG,qBAAqB;AAC9B,sBAAE,qBAAqB;sBACrB,cAAc,CAAC;gBACrB,MAAM,OAAO,GAAG,MAAMA,eAAW,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AAC/C,gBAAA,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;aAC5B;YAAC,OAAO,CAAC,EAAE;AACR,gBAAA,OAAO,CAAC,GAAG,CAAC,kCAAkC,CAAC,CAAC;gBAChD,MAAM,CAAC,CAAC,CAAC,CAAC;aACb;AACL,SAAC,CAAC,CAAC;AACP,KAAC,CAAA;AAED;;;;;;;;;;;;;AAaG;AACH,IAAA,eAAe,GAAG,CAAC,IAAiB,EAAE,QAAgB,KAAsB;AACxE,QAAA,OAAO,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;AACjC,KAAC,CAAA;AAED;;;;;;;;;;;;;;;;;AAiBG;AACH,IAAA,iBAAiB,GAAG,CAAC,IAAsB,EAAE,QAAgB,KAAiB;QAC1E,OAAOA,eAAW,CAAC,QAAQ,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;AAChD,KAAC,CAAA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCG;AACH,IAAA,0BAA0B,GAAG,CAAC,YAAiB,EAAE,YAAoB,KAAsB;AACvF,QAAA,MAAM,IAAI,GAAG;AACT,YAAA,QAAQ,EAAE;AACN,gBAAA,OAAO,EAAE,CAAC,OAAO,EAAC,SAAS,CAAC;AAC5B,gBAAA,IAAI,EAAE,CAAC,QAAQ,EAAC,mBAAmB,CAAC;AACpC,gBAAA,OAAO,EAAE,GAAG;AACf,aAAA;AACD,YAAA,IAAI,EAAE;AACF,gBAAA,IAAI,EAAE,YAAY;AACrB,aAAA;SACJ,CAAC;QAEF,MAAM,2BAA2B,GAAG,MAAM,CAAC,MAAM,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;AAEtE,QAAA,OAAO,2BAA2B,CAAC;AACvC,KAAC,CAAA;AAED;;;;;;;;;;;;;;;;;AAiBG;AACH,IAAA,oBAAoB,GAAG,CAAC,IAAsB,KAAI;AAC9C,QAAA,MAAM,cAAc,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC,CAAC;AACxD,QAAA,OAAO,cAAc,CAAC,UAAU,CAAC,CAAC;AAClC,QAAA,OAAO,cAAc,CAAC,MAAM,CAAC,CAAC;AAE9B,QAAA,OAAO,cAAc,CAAC;AAC1B,KAAC,CAAA;IAED,iBAAiB,GAAG,YAAW;AAC3B,QAAA,MAAM,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,CAAC;AACpC,KAAC,CAAA;AAED;;;;;;;AAOG;;;;;;;;;;;;AAeH,IAAA,yBAAyB,GAAG,CAAC,aAAoB,KAAc;QAC3D,OAAO,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;AAC/C,KAAC,CAAA;IAED,qCAAqC,GAAG,CACpC,aAAoB,EACpB,WAAmB,EACnB,aAAsC,KAC5B;AACV,QAAA,OAAO,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC;AAC3E,KAAC,CAAA;IAEO,eAAe,GAAG,OAAO,MAAoB,EAAE,SAA0B,EAAE,KAAiB,KAAI;AACpG,QAAA,IAAI,CAAC,SAAS;YAAE,OAAO;AACvB,QAAA,IAAI,QAAkC,CAAC;QACvC,QAAQ,MAAM;AACV,YAAA,KAAK,WAAW;AACZ,gBAAA,QAAQ,GAAG,SAAS,CAAC,SAAS,CAAC;AAC/B,gBAAA,IAAI,QAAQ;AAAE,oBAAA,QAAQ,EAAE,CAAC;gBACzB,MAAM;AACV,YAAA,KAAK,SAAS;AACV,gBAAA,QAAQ,GAAG,SAAS,CAAC,OAAO,CAAC;AAC7B,gBAAA,IAAI,QAAQ;AAAE,oBAAA,QAAQ,EAAE,CAAC;gBACzB,MAAM;AACV,YAAA,KAAK,QAAQ;AACT,gBAAA,QAAQ,GAAG,SAAS,CAAC,MAAM,CAAC;AAC5B,gBAAA,IAAI,QAAQ;AAAE,oBAAA,QAAQ,EAAE,CAAC;gBACzB,MAAM;AACV,YAAA,KAAK,SAAS;AACV,gBAAA,QAAQ,GAAG,SAAS,CAAC,OAAO,CAAC;gBAC7B,IAAI,QAAQ,EAAE;oBACV,MAAM,IAAI,GAAG,QAA2C,CAAC;oBACzD,IAAI,CAAC,KAAK,CAAC,CAAC;iBACf;gBACD,MAAM;AACV,YAAA,KAAK,gBAAgB;AACjB,gBAAA,QAAQ,GAAG,SAAS,CAAC,cAAc,CAAC;AACpC,gBAAA,IAAI,QAAQ;oBAAE,MAAM,QAAQ,EAAE,CAAC;gBAC/B,MAAM;AACV,YAAA,KAAK,cAAc;AACf,gBAAA,QAAQ,GAAG,SAAS,CAAC,YAAY,CAAC;AAClC,gBAAA,IAAI,QAAQ;oBAAE,MAAM,QAAQ,EAAE,CAAC;gBAC/B,OAAO;AACX,YAAA,KAAK,aAAa;AACd,gBAAA,QAAQ,GAAG,SAAS,CAAC,WAAW,CAAC;AACjC,gBAAA,IAAI,QAAQ;oBAAE,MAAM,QAAQ,EAAE,CAAC;gBAC/B,OAAO;AACX,YAAA,KAAK,cAAc;AACf,gBAAA,QAAQ,GAAG,SAAS,CAAC,YAAY,CAAC;gBAClC,IAAI,QAAQ,EAAE;oBACV,MAAM,IAAI,GAAG,QAAoD,CAAC;AAClE,oBAAA,MAAM,IAAI,CAAC,KAAK,CAAC,CAAC;iBACrB;gBACD,OAAO;SACd;AACL,KAAC,CAAA;;;;;"}